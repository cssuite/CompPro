/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <colorchat>
#include <dhudmessage>
//#include <sockets>

new const PLUGIN[] = 	"Comp::Pro"
new const VERSION[] =   "4.0"
new const AUTHOR[] =  	"RevCrew"

new const MAIN_SITE[] = "cs-suite.ru"
new const PREFIX[] = 	"Comp::Pro"

#pragma ctrlchar '\'
#define DEBUG

#define get_bit(%1,%2) 		( %1 &   1 << ( %2 & 31 ) )

#define TYPE_MAX_LEN 	256
#define DELAY_MAX_LEN 	256
#define COMPID_MAX_LEN	256

#define POINTER_POINTER 	sizeof(BASE_LEN)-2
#define TASK_DISPLAY_ID		1443
#define TEXT_LEN		192
#define COPY_DATA_LEN		255

const START 	= 	0;
const END 	= 	6;

enum
{
	COP_OPEN_DIR = 0, COP_NOFILES, COP_EMPTYDIR
}

#include "include/CompPro/stock.inl"

/*
	Сделать система Error'ов для кода
	СДелать API для создания композиций прямо в кс
	Сделать обновления 
	Скорость hud\dhud сообщений
*/

enum _:CompParams
{
	PARAM_CLEAR_DHUD = 0,
	PARAM_DISPLAY_ALIVE,
	PARAM_DISPLAY_DEATH
}

new ParamsList[CompParams][]=
{
	"PARAM_CLEAR_DHUD_CHANNEL",
	"PARAM_DISPLAY_ALIVE",
	"PARAM_DISPLAY_DEATH"
}

enum _:ParamData
{
	p_DisplayAlive = 0,
	p_DisplayDeath
}

enum _:TaskData
{
	td_curr = 0,
	td_sync
}
enum _:CompData
{
	COMP_TEXT[TEXT_LEN], COMP_RGB[3], Float:COMP_X, Float:COMP_Y, COMP_TYPE, Float:COMP_HOLD, COMP_CHANNEL,
}

new Array: g_comp_data

enum _:Comps
{
	C_PARAM,
	C_PLAYER_FLAG,
	C_TYPE[TYPE_MAX_LEN],
	C_DELAY[DELAY_MAX_LEN],
	C_COMP_ID[COMPID_MAX_LEN],
}
new Array: g_comps

new const BASE [][] = 
{
	"$start=", "$param=", "$player_flag=", "$type=", "$delay=", "$message=","$end="
}
new const BASE_LEN [] = 
{ 
	7,7,13, 6, 7, 9, 5
}
	

enum Teams
{
	TEAM_TT,
	TEAM_CT
}

new g_Score[Teams];

public plugin_init() 
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	register_event("TeamScore", "team_score", "a"); 
	
	static LogDir[64]; get_localinfo("amxx_logs", LogDir, charsmax(LogDir))
	
	add(LogDir,charsmax(LogDir), "/CompPro")
	if(!dir_exists(LogDir))	mkdir(LogDir)
	
	g_comp_data = ArrayCreate(CompData);
	g_comps = ArrayCreate(Comps)
	
}
public plugin_cfg()
	set_task(0.5, "LoadComposition")
	
public plugin_end()
{
	ArrayDestroy(g_comp_data);
	ArrayDestroy(g_comps);
}

public team_score()
{
	new team[32];
	read_data(1, team, charsmax(team))
	
	switch (team[0])
	{
		case 'C': g_Score[TEAM_CT] = read_data(2);
		case 'T': g_Score[TEAM_TT] = read_data(2);
	}
}

public TaskDisplayComp( comp_id )
{
	comp_id -= TASK_DISPLAY_ID;

	new data[Comps];
	ArrayGetArray(g_comps, comp_id, data);

	new taskData[TaskData];
	taskData[td_curr] = 0;

	TaskDelayedComp(taskData, comp_id+TASK_DISPLAY_ID)
	return;
}
public TaskDelayedComp(taskData[TaskData], comp_id)
{
	comp_id -=TASK_DISPLAY_ID;

	new curr = taskData[td_curr];
	new data[Comps], data_c[CompData];
	ArrayGetArray(g_comps, comp_id, data);
	
	if(!curr)
		curr = 1;
	
	new  c_id[4], c_dl[4],c_type[4];
	new temp[3][COPY_DATA_LEN+1];

	copy(temp[0], COPY_DATA_LEN, data[C_TYPE]);
	copy(temp[1], COPY_DATA_LEN, data[C_DELAY]);
	copy(temp[2], COPY_DATA_LEN, data[C_COMP_ID]);

	strbreak(temp[1], c_dl, charsmax(c_dl), temp[1], COPY_DATA_LEN)

	for(new i = 0; i<curr; i++)
	{
		if(strlen(temp[0]) <= 0)
		{
			StartTaskComp(data[C_DELAY],comp_id);
			break;
		}
	
		strbreak(temp[0], c_type, charsmax(c_type), temp[0],  COPY_DATA_LEN)
		strbreak(temp[1], c_dl, charsmax(c_dl), temp[1],  COPY_DATA_LEN)
		strbreak(temp[2], c_id, charsmax(c_id), temp[2],  COPY_DATA_LEN)
	}
	
	curr++;
	ArrayGetArray(g_comp_data, str_to_num(c_id), data_c)
	
	static param_data[ParamData];
	param_data[p_DisplayAlive] = bool:(get_bit(data[C_PARAM], PARAM_DISPLAY_ALIVE));
	param_data[p_DisplayDeath] = bool:(get_bit(data[C_PARAM], PARAM_DISPLAY_DEATH));
	DisplayComp(data_c,c_type[0] ,data[C_PLAYER_FLAG], param_data);
	
	new tskdata[TaskData];
	tskdata[td_curr] = curr;
	if(strlen(temp[0]) <= 0)
	{
		if( get_bit(data[C_PARAM],PARAM_CLEAR_DHUD) && containi(data[C_TYPE], "d") != -1)
			for(new i ; i<8;i++)	show_dhudmessage(0, "");
			
		StartTaskComp(data[C_DELAY],comp_id);
	}
		
	else	
		set_task(str_to_float(c_dl), "TaskDelayedComp", comp_id+TASK_DISPLAY_ID, tskdata, sizeof(tskdata));
}
public DisplayComp( data[CompData], type,  flag, pData[ParamData])
{
	
	static p[32], c, player;
	
	if(pData[p_DisplayAlive])
		get_players(p,c, "cha");
	else if(pData[p_DisplayDeath])
		get_players(p,c, "chb");
	else
		get_players(p,c, "ch");
	
	static text[192];
	copy(text,charsmax(text),data[COMP_TEXT])
	
	comp_replace(text, charsmax(text))

	switch(type)
	{
		case 'c':
		{
			for(new i = 0; i<c;i++)
			{
				player = p[i];
				if(!flag || get_user_flags(player) & flag)
					ColorPrint(player,"\1%s",text)
			}
		}
		
		case 'h' :
		{
			replace_all(data[COMP_TEXT], TEXT_LEN-1, "^n", "\n")
			set_hudmessage(data[COMP_RGB][0],data[COMP_RGB][1],data[COMP_RGB][2],data[COMP_X],data[COMP_Y],data[COMP_TYPE],0.1,data[COMP_HOLD],0.1,0.1,data[COMP_CHANNEL])

			for(new i = 0; i<c;i++)
			{
				player = p[i];
				if(!flag || get_user_flags(player) & flag)
					show_hudmessage(player, "%s",text)
			}	
		}
		case 'd' :
		{
			replace_all(data[COMP_TEXT], TEXT_LEN-1, "^n", "\n")
			set_dhudmessage(data[COMP_RGB][0],data[COMP_RGB][1],data[COMP_RGB][2],data[COMP_X],data[COMP_Y],data[COMP_TYPE],0.1,data[COMP_HOLD],0.1,0.1,bool:data[COMP_CHANNEL])
			
			static p[32],c,player;
			get_players(p,c, "ch")
			for(new i = 0; i<c;i++)
			{
				player = p[i];
				if(!flag || get_user_flags(player) & flag)
					show_dhudmessage(player, "%s",text)
			}	
		}
	}
}
public LoadComposition()
{
	/* 	Load Composition	*/
	new File[64];	get_localinfo("amxx_configsdir",File,charsmax(File))
	
	add(File,charsmax(File),"/CompPro/")
	if(!dir_exists(File))	ErrorState(COP_OPEN_DIR, "Can't open /CompPro/ dir");
	
	new curr[64],path[128], bool:find,Dir = open_dir(File, curr, charsmax(curr));
	
	if(Dir)
	{
		do
	{
		
		format( path , sizeof(path)-1 , "%s%s" , File , curr)
		if(dir_exists(path) && curr[0] != '.')
		{
			
			if(path[strlen(path)-1] != '/')	add(path, sizeof(path)-1,"/")
			
			#if defined DEBUG
			PrintMessage("Dir::'%s'", path);
			#endif

			if(!find)	find = check_files(path,curr);
			else		check_files(path,curr);
			
		}
		
	}
	while(next_file(Dir, curr, charsmax(curr)))
		close_dir(Dir)
	}
	
	if(!find)	ErrorState(COP_NOFILES, "Can't find any composition")
}
bool:check_files( File[], toLog[])
{
	new curr[32],path[128],bool:find,Dir = open_dir(File, curr, charsmax(curr));
	if(Dir)
	{
		do
		{
			
			if( !is_bad_file(curr, strlen(curr)) )
			{
				format( path , sizeof(path)-1 , "%s%s" , File , curr)				
				
				#if defined DEBUG
				PrintMessage("Found::%s/%s",toLog, curr);
				#endif
				
			
				find = ParseFileComp(path)
				//server_print("Find::%d",find)
			}
		
		}
		while(next_file(Dir, curr, charsmax(curr)))
		
		close_dir(Dir)
	}

	return find;
}
bool:ParseFileComp( const path[] )
{
	new f = fopen(path,"r")
	
	if(!f)
		return false;
	
	new filedata[256], bool:start = false, pointer = -1;
	new data[Comps]

	while(!feof(f))
	{
		fgets(f, filedata, charsmax(filedata))
	
		delete_comment(filedata);
		if(!filedata[0] || filedata[0] != '$')
			continue;
		
		CheckStartComp(filedata, start, BASE[START],BASE_LEN[START], BASE[END], BASE_LEN[END]);
		
		if(!start)
			continue;
		
		switch(pointer)
		{
			case 0:
			{
				trim(filedata[BASE_LEN[pointer+1]]);
				remove_quotes(filedata[BASE_LEN[pointer+1]]);
				
				replace_all(filedata[BASE_LEN[pointer+1]], charsmax(filedata), "\"", "");
				
				data[C_PARAM]=0;
				for(new i=0;i<sizeof(ParamsList);i++)
				{
					data[C_PARAM]|=((containi(filedata[BASE_LEN[pointer+1]], ParamsList[i])==-1)?0:1)<<i;
				}
					
				
			}
			case 1:
			{
				trim(filedata[BASE_LEN[pointer+1]]);
				remove_quotes(filedata[BASE_LEN[pointer+1]]);
				
				replace_all(filedata[BASE_LEN[pointer+1]], charsmax(filedata), "\"", "");
				data[C_PLAYER_FLAG] = read_flags(filedata[BASE_LEN[pointer+1]]);
			}
			case 2:
			{
				trim(filedata[BASE_LEN[pointer+1]]);
				remove_quotes(filedata[BASE_LEN[pointer+1]]);
				
				replace_all(filedata[BASE_LEN[pointer+1]], charsmax(filedata), "\"", "");
				copy(data[C_TYPE], TYPE_MAX_LEN -1, filedata[BASE_LEN[pointer+1]]);
			}
			case 3:
			{
				trim(filedata[BASE_LEN[pointer+1]]);
				remove_quotes(filedata[BASE_LEN[pointer+1]]);
				
				replace_all(filedata[BASE_LEN[pointer+1]], charsmax(filedata), "\"", "");
				copy(data[C_DELAY], DELAY_MAX_LEN -1, filedata[BASE_LEN[pointer+1]]);
			}
			default: 
			if(pointer != -1)	formatex(data[C_COMP_ID], COMPID_MAX_LEN - 1, "%s %d", data[C_COMP_ID],parse_comp(filedata[BASE_LEN[POINTER_POINTER]], charsmax(filedata)));
		}

		pointer++
		
	}
	
	fclose(f);
	ArrayPushArray(g_comps, data);
	StartTaskComp(data[C_DELAY], ArraySize(g_comps)-1);
	return true;
}
public parse_comp( str[], len)
{
	new data[CompData];
	
	strbreak(str, data[COMP_TEXT], TEXT_LEN-1, str, len);
	
	if( strlen(str) < 2 )
	{
		// Chat comp
		ArrayPushArray(g_comp_data, data);
		return ArraySize(g_comp_data)-1;
	}
	
	new rgb[12];
	strbreak(str, rgb, charsmax(rgb), str, len)
	
	new r[4], g[4], b[4];
	parse(rgb, r, 3, g, 3, b, 3);
	
	data[COMP_RGB][0] = str_to_num(r);
	data[COMP_RGB][1] = str_to_num(g);
	data[COMP_RGB][2] = str_to_num(b);
	
	new float_x[6], float_y[6];
	strbreak(str, float_x, charsmax(float_x), str, len)
	strbreak(str, float_y, charsmax(float_y), str, len)
	
	data[COMP_X] = _:str_to_float(float_x);
	data[COMP_Y] = _:str_to_float(float_y);
	
	new type[22];
	strbreak(str, type, charsmax(type), str, len)
	
	if(containi(type,"DEF") != -1)
		data[COMP_TYPE] = 0;
	else if (containi(type,"Fade") != -1)
		data[COMP_TYPE] = 1;
	else if (containi(type,"Print") != -1)
		data[COMP_TYPE] =2;
		
	new duration[6];
	strbreak(str, duration, charsmax(duration), str, len)
	
	data[COMP_HOLD] = _:str_to_float(duration);
	
	new channel[3];
	strbreak(str, channel, charsmax(channel), str, len)
	
	data[COMP_CHANNEL] = str_to_num(channel);

	ArrayPushArray(g_comp_data, data);
	
	//log_amx("Text[%s]",data[COMP_TEXT])
	
	return ArraySize(g_comp_data)-1;
}
comp_replace(text[], len)
{
	static str[64];
	get_cvar_string("hostname", str, charsmax(str))
	
	static server_ip[24];
	get_user_ip(0, server_ip, charsmax(server_ip), 0)
	
	static playersnum[6];
	num_to_str(get_playersnum(), playersnum, charsmax(playersnum))
	
	static pl[2][6];
	static p[32],c[2];
	get_players(p, c[0],"cha")
	get_players(p, c[1],"chb")
	
	num_to_str(c[0], pl[0], charsmax(pl[]))
	num_to_str(c[1], pl[1], charsmax(pl[]))
	
	static mapname[32];
	get_mapname(mapname, charsmax(mapname))

	replace_all(text, len, "%hostname%", str)
	replace_all(text, len, "%server_ip%", server_ip)
	replace_all(text, len, "%playersnum%", playersnum)
	replace_all(text, len, "%players_alive%", pl[0])
	replace_all(text, len, "%players_death%", pl[1])
	replace_all(text, len, "%mapname%",mapname)
	
	new teams_score[Teams][5];
	
	num_to_str(g_Score[TEAM_TT], teams_score[TEAM_TT], sizeof(teams_score[]) - 1)
	num_to_str(g_Score[TEAM_CT], teams_score[TEAM_CT], sizeof(teams_score[]) - 1)
	
	replace_all(text, len, "%score_tt%", teams_score[TEAM_TT])
	replace_all(text, len, "%score_ct%", teams_score[TEAM_CT])
	
	replace_all(text, len, "%n%","\n");

	//server_print("'%s'",text)
}

